# C++ 后端开发面试题-语言基础篇

### 1、指针和引用的区别

> 指针和引用都是一种内存地址的概念，区别呢，指针是一个实体，引用只是一个别名。
>
> 在程序编译的时候，将指针和引用添加到符号表中。
>
> 指针它指向一块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将“指针变量名-指针变量的地址”添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷贝和赋值，有 const 和非 const 区别，甚至可以为空，sizeof 指针得到的是指针类型的大小。
>
> 而对于引用来说，它只是一块内存的别名，在添加到符号表的时候，是将"引用变量名-引用对象的地址"添加到符号表中，符号表一经完成不能改变，所以引用必须而且只能在定义时被绑定到一块内存上，后续不能更改，也不能为空，也没有 const 和非 const 区别，sizeof 引用得到代表对象的大小。另外在参数传递中，指针需要被解引用后才可以对对象进行操作，而直接对引用进行的修改会直接作用到引用对象上。

## 2、C++ 中内存分配情况

> （1）栈：由编译器管理分配和回收，存放局部变量和函数参数。
>
> （2）堆：由程序员管理，需要手动 new malloc delete free 进行分配和回收，空间较大，但可能会出现内存泄漏和空闲碎片的情况。
>
> （3）全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。
>
> （4）常量存储区：存储常量，一般不允许修改。
>
> （5）代码区：存放程序的二进制代码。

## 3、堆和栈区别

> 栈
>
> （1）由编译器进行管理，在需要时由编译器自动分配空间，在不需要时候自动回收空间，一般保存的是局部变量和函数参数等。
>
> （2）连续的内存空间，在函数调用的时候，首先入栈的主函数的下一条可执行指令的地址，然后是函数的各个参数。
>
> （3）大多数编译器中，参数是从右向左入栈（原因在于采用这种顺序，是为了让程序员在使用C/C++的“函数参数长度可变”这个特性时更方便。如果是从左向右压栈，第一个参数（即描述可变参数表各变量类型的那个参数）将被放在栈底，由于可变参的函数第一步就需要解析可变参数表的各参数类型，即第一步就需要得到上述参数，因此，将它放在栈底是很不方便的。）本次函数调用结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运行，不会产生碎片。
>
> （4）栈是高地址向低地址扩展，栈低高地址，空间较小。

> 堆：
>
> （1）由程序员管理，需要手动 new malloc delete free 进行分配和回收，如果不进行回收的话，会造成内存泄漏的问题。
>
> （2）不连续的空间，实际上系统中有一个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第一个大于等于申请大小的空间分配给程序，一般在分配程序的时候，也会空间头部写入内存大小，方便 delete 回收空间大小。当然如果有剩余的，也会将剩余的插入到空闲链表中，这也是产生内存碎片的原因。
>
> （3）堆是低地址向高地址扩展，空间交大，较为灵活。

## 4、函数传递参数的几种方式

> （1）值传递：形参是实参的拷贝，函数内部对形参的操作并不会影响到外部的实参。
>
> （2）指针传递：也是值传递的一种方式，形参是指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行操作。
>
> （3）引用传递：实际上就是把引用对象的地址放在了开辟的栈空间中，函数内部对形参的任何操作可以直接映射到外部的实参上面。

## 5、new / delete malloc / free 区别

都可以用来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是函数。

> （1）执行 new 实际上执行两个过程：1.分配未初始化的内存空间（malloc）；2.使用对象的构造函数对空间进行初始化；返回空间的首地址。如果在第一步分配空间中出现问题，则抛出 std::bad_alloc 异常，或被某个设定的异常处理函数捕获处理；如果在第二步构造对象时出现异常，则自动调用 delete 释放内存。
>
> （2）执行 delete 实际上也有两个过程：1. 使用析构函数对对象进行析构；2.回收内存空间（free）。
>
> （3）以上也可以看出 new 和 malloc 的区别，new 得到的是经过初始化的空间，而 malloc 得到的是未初始化的空间。所以 new 是 new 一个类型，而 malloc 则是malloc 一个字节长度的空间。delete 和 free 同理，delete 不仅释放空间还析构对象，delete 一个类型，free 一个字节长度的空间。
>
> （4）为什么有了 malloc／free 还需要 new／delete？因为对于非内部数据类型而言，光用 malloc／free 无法满足动态对象的要求。对象在创建的同时需要自动执行构造函数，对象在消亡以前要自动执行析构函数。由于 mallo／free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行的构造函数和析构函数的任务强加于 malloc／free，所以有了 new／delete 操作符。

## 6、volatile 和 extern 关键字

**volatile 三个特性**

> （1）易变性：在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的 volatile 变量的寄存器内容，而是重新从内存中读取。
>
> （2）不可优化性：volatile 告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。
>
> （3）顺序性：能够保证 volatile 变量之间的顺序性，编译器不会进行乱序优化。

**extern** 

> 在 C 语言中，修饰符 extern 用在变量或者函数的声明前，用来说明 “此变量/函数是在别处定义的，要在此处引用”。
>
> 注意 extern 声明的位置对其作用域也有关系，如果是在 main 函数中进行声明的，则只能在 main 函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用 #include 包含进来即可，为啥要用 extern？因为用 extern 会加速程序的编译过程，这样能节省时间。
>
> 在 C++ 中 extern 还有另外一种作用，用于指示 C 或者 C＋＋函数的调用规范。比如在 C＋＋ 中调用 C 库函数，就需要在 C＋＋ 程序中用 extern “C” 声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C 函数规范来链接。主要原因是 C＋＋ 和 C 程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。

## 7、C++ 中 const 和 static 关键字（定义，用途）

**static 作用：控制变量的存储方式和可见性。**

> **（1）修饰局部变量**：一般情况下，对于局部变量在程序中是存放在栈区的，并且局部的生命周期在包含语句块执行结束时便结束了。但是如果用 static 关键字修饰的话，该变量便会存放在静态数据区，其生命周期会一直延续到整个程序执行结束。但是要注意的是，虽然用 static  对局部变量进行修饰之后，其生命周期以及存储空间发生了变化，但其作用域并没有改变，作用域还是限制在其语句块。
>
> **（2）修饰全部变量**：对于一个全局变量，它既可以在本文件中被访问到，也可以在同一个工程中其它源文件被访问(添加 extern进行声明即可)。用 static 对全局变量进行修饰改变了其作用域范围，由原来的整个工程可见变成了本文件可见。
>
> **（3）修饰函数**：用 static 修饰函数，情况和修饰全局变量类似，也是改变了函数的作用域。
>
> **（4）修饰类**：如果 C++ 中对类中的某个函数用 static  修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行 static 修饰，则表示该变量以及所有的对象所有，存储空间中只存在一个副本，可以通过；类和对象去调用。
>
> **（5）补充**：静态非常量数据成员，其只能在类外定义和初始化，在类内仅是声明而已。
